【项目标准】
1. 固定窗口大小：小窗600*400，大窗1000*600
2. 数据管理分内存和外存，绝大部分页面只需要内存，外存只在靠外的几个页面涉及。
3. 页面跳转connect一律写在前一页面，整个程序是树状结构，禁止环，避免过长的返回树枝
4. 所有表格：行数声明为ULL， 循环变量i声明为ULL，其他地方一律强制转换
5. 所有函数：输入参数一律const引用， 输出参数一律引用
6. 所有类：一律显式写出无参数构造函数，拷贝构造函数，虚析构函数，赋值运算符
7. 所有使用自定义指针的Global、Platform方法先判断存在性！！！

【编码提醒】
★不能把成员变量直接推入静态/全局的vector！！！！
★迭代器解引用再取地址才是真实地址！
★同时使用User和Mission时要include <global.h>
★int转QString要用QString::number();
★【添加新任务】【报名负责人】【确认负责人】
    【报名译者】
1.任务状态变更
2.用户列表变更（当事人+相关人员）
3.全局列表变更    //仅确认
★ 继承QObject类以后出现LNK2001，将所有生成文件夹的东西清空就好了！！！


【项目设定】
1.1 任务发布状态：
正在招募(R_RECRUIT_M)【招募负责人】
招募失败(R_RCRT_M_FAILED)【任务大厅不显示】
选择负责人(R_CHOOSE_M)【任务大厅不显示】
已取消(R_CANCELED)【任务大厅不显示】
进行中(R_TRANSLATING)【招募译者/翻译进行中】
等待支付( R_WAIT_FOR_PAY)【任务大厅显示已完成】
已完成(R_ACCOMPLISHED)【已完成】
(个人申请状态：申请中(applyingM), 申请失败(applyMFailed), 申请成功(aplMAccepted))

1.2 任务征集状态
正在招募(M_RECRUIT_T)【招募译者】
招募失败(M_RCRT_T_FAILED)【任务大厅不显示】
选择并分配(M_CHS_T_AND_ASSIGN)【翻译进行中】
审核中(M_CHECKING)【翻译进行中】
超时失败(M_TIME_OUT)【任务大厅不显示】
已提交(M_SUBMITTED)【已完成】
已完成(M_ACCOMPLISHED)【已完成】
(个人申请状态：申请中(applyingT), 申请失败(applyTFailed), 申请成功(aplTAccepted))

1.3 任务翻译状态/子任务状态
待翻译(T_WAIT_FOR_TRANS)
已提交(T_SUBMITTED)
待修改(T_WAIT_FOR_MODIFY)
已接受(T_ACCEPTED)
已完成(T_ACCOMPLISHED)

2. 积分规则
2.1 积分>=10可成为负责人
2.2 初始积分：
大学四级        5
大学六级        7
专业八级        9

TOFEL
[0, 69]        3
[70, 90]       7
[90, 99]       8
[100, 109]     9
[110, 120]     10

YELTS
[0, 4]         3
[4.5, 5.5]     5
[6, 7.5]       7
[8, 9]         9

GRE(仅Verbel)
[130, 149]     5
[150, 154]     7
[155, 159]     9
[160, 170]     11


3. 酬金分配规则
负责人和所有译者三七分，译者按照贡献多少（翻译的字符串长短）分享70%部分。

4. 用户信息页展示规则

4.1 发布的任务：显示所有，以及其状态
4.2 负责的任务：只显示申请通过的
4.3 参与的任务：只显示申请通过的


5. 任务信息页展示规则
5.1
任务信息页分为四个模块，查看时不区分查看者身份，只区分任务阶段
5.2
四个模块分别为：基本信息，负责人信息，翻译者信息，任务成果
基本信息：【都有】
任务名，发布者，源语言，简介，任务DDL，招募译者截止时间，赏金，发布状态
负责人信息：【R_TRANSLATING及以后】
负责人，任务负责状态
译者信息：【M_CHECKING及以后】
译者及其子任务翻译状态
任务成果：【M_SUBMITTED及以后】
任务的全部原文及译文


6. 任务时间序列规则
6.1 任务招募M时间至少为当前时间的1天后
6.2 任务DDL至少为初始招募M时间的3天后
6.3 任务招募T时间至少为选择负责人的当前时间

7. 名称规范
任务名、用户名禁止含有如下特殊符号：{ ” ’ ( ) ; | # }

【报错规范】
Error (num) : (description)
    from (function name)



【v3.0重构策略】
1. 标识符：
所有任务、用户改用名字（std::string）作为唯一标识符
2. Global
Global的静态public变量是内存中所有用户、任务信息的储存位置
Global负责和硬盘的数据交互（load、save）。
Global要支持任何一个对象（User、Mission）的插入、获取、删除
Global要支持任何一个对象（User、Mission）的数据更新


3. 任务数据存储策略

3.1 
所有Mission存在Global的allMissions中
3.2 
用户申请负责人时只将任务名加入自己的申请列表中
3.3
Mission在【确定负责人】时产生一个ManageMission。
此时生成一个ManageMission对象，加入allManageMission表，
并将原Mission对象从allMissions表中删除
由于用户表存储的只是名字，所以不存在问题。
★Global需要有同时对两张表进行查找和维护的能力

3.4 我的任务显示策略
3.4.1 
用户发布列表、负责列表、参与列表中所有任务均显示， 其他均不显示
一个Platform的静态方法实现此功能
3.4.2
对于发布的任务，根据其发布状态，确定按钮是查看信息还是进行操作，以及进行什么操作
3.4.3
对于申请的任务，根据其申请状态，确定按钮是查看信息还是进行操作，以及进行什么操作
一个Mission的非静态成员方法【虚函数】/Platform的静态方法【重载】可以查询某一user对某一mission的申请状态
若申请失败或正在申请则显示，按钮为查看任务详情【重载即可】
若申请成功则显示，按钮由一个页面类的成员函数【重载】设置
若未在申请则不显示[并报错]
另一个Mission的非静态成员方法【虚函数】根据上述查询函数决定mission在其上的显示模式

3.5 
ManageMission 在【分配任务】时为每一个翻译者生成一个子任务
所有子任务放在allSubMissions表中
每一个SubMission以typedef pair<std::string, std::string> KEY_SUB 为唯一标识符[任务名, 翻译者名]
3.6
Global提供对于SubMission的如下功能：
3.6.1 按照传入的pair<std::string, std::string>（译者名和分配的译文）建立相应数目子任务并存入表中
3.6.2 根据任务名和编号返回对应的子任务的引用
3.7
SubMission的自定义指针为P_SUB，可根据自己的名字和任务名寻找对应子任务
3.8
Platform提供如下服务：
获取所有某一用户发布/负责的任务，获取所有某一用户翻译的子任务








